# Main Game Scene
# Entirely written by humans with assistance from Copilot (75% human, 25% AI)
import math
import pygame
import globals
from utils.camera import Camera
from utils.platform import Platform
from utils.player import Player

from utils.scene import SceneBase


class GameScene(SceneBase):
    def __init__(self):
        self.camera = Camera()
        self.player = Player()
        self.angle = 0
        self.platforms = [Platform(0, 100, Platform.TYPE_GRASS, platform_width_type=Platform.WIDTH_FLOOR, platform_x_velocity=0)]

    def update(self, dt):
        mouse_x, mouse_y = pygame.mouse.get_pos()
        player_x, player_y = self.player.x + (Player.CHARACTER_WIDTH / 2), self.camera.calculate_pygame_pos(self.player.y)

        # This line is entirely generated by Copilot
        self.angle = math.atan2(mouse_y - player_y, mouse_x - player_x)

        # Process Jump
        if pygame.mouse.get_pressed()[0] and self.player.checkCanJump(self.platforms):

            self.player.jump(self.angle)
        
        # Update player
        self.player.update(dt, self.platforms)

        pass

    def render(self):
        # Clear screen
        globals.screen.fill((255, 255, 255))

        # Render player
        globals.screen.blit(self.player.IMAGE, (self.player.x, self.camera.calculate_pygame_pos(self.player.y)))

        # Render arrow (THIS LINE IS FULLY GENERATED BY COPILOT)
        pygame.draw.line(globals.screen, (0, 0, 0), (self.player.x + (Player.CHARACTER_WIDTH / 2), self.camera.calculate_pygame_pos(self.player.y)), (pygame.mouse.get_pos()[0], pygame.mouse.get_pos()[1]), 5)
        # Render platforms (platform image repeats every 80 pixels)
        for i in self.platforms:
            for j in range(0, i.width, 80):
                globals.screen.blit(i.getPlatformImage(), (i.x + j, self.camera.calculate_pygame_pos(i.y)))

    def handle_events(self, events):
        pass